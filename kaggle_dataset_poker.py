# -*- coding: utf-8 -*-
"""Kaggle_dataset_poker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nf_EMEncUTENqxKQOd9_5pJtHMCmY3SN

Kaggle Poker Holdem Dataset

link: https://www.kaggle.com/datasets/smeilz/poker-holdem-games/data
"""

"""**1. Import the data files from Kaggle:**



"""

import zipfile
import os
import re

def extract_txt_from_zip(zip_file_path, output_folder_path):
    # Create output folder
    os.makedirs(output_folder_path, exist_ok=True)

    # Open the zip file
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        # Get all files in the zip file
        file_list = zip_ref.namelist()

        # Extract .txt files
        for file in file_list:
            if file.endswith('.txt'):
                # Extract to the specified output folder
                zip_ref.extract(file, output_folder_path)

    print(f"Extraction completed. Text files extracted to: {output_folder_path}")


# zip_file_path = '/content/poker-holdem-games.zip'
# output_folder_path = '/content/output_folder'

# extract_txt_from_zip(zip_file_path, output_folder_path)

"""**2. Create the Card Class**"""

import numpy as np

class Card:
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    suits = ['s', 'h', 'c', 'd']

    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
        self.vector = self.to_vector()

    def to_vector(self):
        rank_index = self.ranks.index(self.rank)
        suit_index = self.suits.index(self.suit)

        vector = np.zeros(len(self.ranks) + len(self.suits))
        vector[rank_index] = 1
        vector[len(self.ranks) + suit_index] = 1

        return vector

    def __repr__(self):
        return f"Card(rank={self.rank}, suit={self.suit}, vector={self.vector})"

# # Example usage
# card = Card('10', 'h')
# print(card)

# # Output the vector directly
# print(card.vector)

"""**3. Create the Player Class**"""

class Actions:
  def __init__(self, order, player_name, player_stack, player_action, player_bet):
    self.order = order
    self.player_name = player_name
    self.player_stack = player_stack
    self.player_action = player_action
    self.player_bet = player_bet
  def __repr__(self):
    return f"Order: {self.order}, Player: {self.player_name}, Stack: {self.player_stack}, Action: {self.player_action}, Bet: {self.player_bet}"

class PlayerAction:
    def __init__(self, order, player_name, player_stack, player_action, player_bet=None):
        self.order = order
        self.player_name = player_name
        self.player_stack = player_stack
        self.player_action = player_action
        self.player_bet = float(player_bet) if player_bet else 0

    def __repr__(self):
        return f"PlayerAction(order={self.order}, player_name='{self.player_name}', player_stack={self.player_stack}, " \
               f"player_action='{self.player_action}', player_bet={self.player_bet})"


class PokerHand:
    def __init__(self, game_id, start_money, hole_cards, small_blind, num_players, player_position, has_small_blind, has_big_blind, min_raise_amount, min_call_amount, allin_amount, my_action, prior_actions):
        self.game_id = game_id
        self.start_money = start_money
        self.hole_cards = hole_cards
        self.num_players = num_players
        self.small_blind = small_blind
        self.big_blind = small_blind * 2
        self.num_players = num_players
        self.player_position = player_position
        self.has_small_blind = has_small_blind
        self.has_big_blind = has_big_blind
        self.my_action = my_action
        self.prior_actions = prior_actions
        self.min_raise_amount = min_raise_amount
        self.min_call_amount = min_call_amount
        self.allin_amount = allin_amount


    def __repr__(self):
        return (f"PokerHand(game_id={self.game_id}, start_money={self.start_money}, "
                f"hole_cards={self.hole_cards}, num_players={self.num_players}, player_position={self.player_position}, has_small_blind={self.has_small_blind}, small_blind={self.small_blind}, min_raise={self.min_raise_amount}, call_amount={self.min_call_amount}allin_amount={self.allin_amount}, has_big_blind={self.has_big_blind}, big_blind={self.big_blind}),my_action={self.my_action}, prior_actions={self.prior_actions}")

def parse_game(game_text):
    game_id = re.search(r"Game ID: (\d+)", game_text).group(1)
    seat_info = re.search(r"Seat (\d+): IlxxxlI \((\d+(\.\d+)?)\)", game_text)
    start_money = float(seat_info.group(2))
    hole_cards = re.findall(r"Player IlxxxlI received card: \[([0-9JQKA]{1,2}[shcd])\]", game_text)
    small_blind_match = re.search(r"has small blind \((\d+(\.\d+)?)\)", game_text)
    small_blind = float(small_blind_match.group(1)) if small_blind_match else None
    has_small_blind = False
    has_big_blind = False

    # Finding if we have small or big blind
    small_blind_find = re.findall(r"Player (\w+) has small blind", game_text)

    if small_blind_find != []:
      if small_blind_find[0] == 'IlxxxlI':
        has_small_blind = True

    big_blind_find = re.findall(r"Player (\w+) has small blind", game_text)

    if big_blind_find != []:
      if big_blind_find[0] == 'IlxxxlI':
        has_big_blind = True

   #total number of players
    num_players = len(re.findall(r"Seat \d+: \w+ \(\d+(\.\d+)?\)", game_text))

    # Convert hole_cards to Card objects
    parsed_hole_cards = [Card(card[:-1], card[-1]) for card in hole_cards]


    # Players
    pattern = r"Seat \d+: (\w+) \((\d+\.\d+)\)"
    matches = re.findall(pattern, game_text)

    players = []

    for match in matches:
        player_name = match[0]
        money = float(match[1])
        players.append([player_name, money])

    # List of all actions made that hand
    all_actions = re.findall(r"Player (\w+) (folds|calls|raises|allin)(?: \((\d+(\.\d+)?)\))?", game_text)

    # Extract received card actions for count
    received_cards = re.findall(r"Player (\w+) (received a card|received card)", game_text)
    count = 0

    for p in received_cards:
        if p[0] == 'IlxxxlI':
            break
        count += 1

    player_position = count / 2


    # Create a list of PlayerAction objects
    prior_actions = []
    my_action = None  # Initialize my_action to None since we might not find 'IlxxlI'

    order = 0
    for action in all_actions:
        player_name = action[0]
        action_type = action[1]
        bet_amount = action[2] if len(action) > 2 else 0
        stack = 0
        for player in players:
          if player[0] == player_name:
            stack = player[1]
            break
        order += 1
        if player_name == 'IlxxxlI':
            my_action = PlayerAction(order, player_name, stack, action_type, bet_amount)
            break
        prior_actions.append(PlayerAction(order, player_name, stack, action_type, bet_amount))


    latest_non_fold_action = None
    latest_bet_amount = 0

    #Iterate backwards through prior_actions to find the latest non-fold action
    for action in reversed(prior_actions):
        if action.player_action != 'folds':
            latest_non_fold_action = action
            latest_bet_amount = action.player_bet if action.player_bet else 0
            break

    #If no non-fold action found, assume initial state with zero bets
    if not latest_non_fold_action:
        latest_bet_amount = 0



    min_call_amount = small_blind * 2
    min_raise_amount = small_blind * 3
    allin_amount = None

    if latest_bet_amount != 0:
      if has_big_blind == True:
        min_call_amount = latest_bet_amount - (small_blind*2)
        min_raise_amount = latest_bet_amount*2 - (small_blind*2)
      if has_small_blind == True:
        min_call_amount = latest_bet_amount - small_blind
        min_raise_amount = latest_bet_amount*2 - (small_blind)
      else:
        min_call_amount = latest_bet_amount
        min_raise_amount = latest_bet_amount*2

      if my_action and my_action.player_stack:
        allin_amount = my_action.player_stack

      # Print results
    #   print(f"Minimum Call Amount: {min_call_amount}")
    #   print(f"Minimum Raise Amount: {min_raise_amount}")



    return PokerHand(game_id, start_money, parsed_hole_cards, small_blind, num_players, player_position, has_small_blind, has_big_blind, min_raise_amount, min_call_amount, allin_amount, my_action, prior_actions)

def read_and_parse_games(filename):
    with open(filename, 'r') as file:
        data = file.read()

    games = data.split('\n\n')  # Assuming games are separated by a blank line
    poker_hands = [parse_game(game) for game in games if game.strip()]

    return poker_hands

def main():
    filename = r'poker_data/File196.txt'
    poker_hands = read_and_parse_games(filename)

    for hand in poker_hands:
        print(hand)

if __name__ == "__main__":
    main()

